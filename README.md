# VeriPass - Decentralized Asset Passport System

## Architecture Overview

VeriPass is a blockchain-based asset verification system that creates tamper-proof digital passports for physical assets. The system tracks ownership history and lifecycle events on an append-only ledger.

```
                                    ARCHITECTURE DIAGRAM
    
    +-------------------+     +-------------------+     +-------------------+
    |     Frontend      |     |      Oracle       |     |      Backend      |
    |   (Vite + React)  |     |    (Node.js)      |     |     (Express)     |
    +--------+----------+     +--------+----------+     +--------+----------+
             |                         |                         |
             |    reads ABI/addresses  |                         |
             +------------+------------+                         |
                          |                                      |
                          v                                      |
                 +--------+----------+                           |
                 |      shared/      |                           |
                 |  (ABI + Addresses)|<--------------------------+
                 +--------+----------+
                          ^
                          | exports after deploy
                          |
             +------------+------------+
             |       Contracts         |
             |       (Hardhat)         |
             +-------------------------+
```

## Folder Structure

```
veripass/
├── contracts/          # Hardhat project - Smart contract development
├── frontend/           # Vite + React - User interface
├── oracle/             # Node.js - External data verification
├── backend/            # Express - Stateless API endpoints
├── shared/             # Cross-layer artifacts (ABI, addresses)
│   ├── abi/            # Contract ABIs (auto-generated)
│   └── addresses.json  # Deployed contract addresses
└── README.md           # This file
```

## Developer Responsibilities

| Developer | Package     | Responsibility                                      |
|-----------|-------------|-----------------------------------------------------|
| Dev A     | contracts/  | Smart contract logic, deployment, ABI generation   |
| Dev B     | frontend/   | UI components, wallet integration, contract calls  |
| Dev C     | oracle/     | External data fetching, verified event submission  |
| Dev C     | backend/    | API endpoints, off-chain data management           |

## Parallel Development Workflow

### Phase 1: Interface Definition (Day 1)

Dev A defines contract interfaces and freezes function signatures. Other developers can begin implementation using placeholder ABIs.

### Phase 2: Parallel Implementation (Day 2-N)

All developers work independently:

- **Dev A**: Implements contract logic, writes tests, prepares deployment
- **Dev B**: Builds UI components, integrates wallet, mocks contract calls
- **Dev C**: Implements oracle data fetching, backend API endpoints

### Phase 3: Integration (Final Day)

Dev A deploys contracts and exports ABIs to shared/. Frontend and Oracle update their imports.

## Cross-Layer Communication Rules

### Rule 1: Single Source of Truth

The `shared/` directory is the ONLY source for contract interfaces:

- **ABIs**: `shared/abi/*.json` - Generated by Hardhat compilation
- **Addresses**: `shared/addresses.json` - Generated by deploy script

### Rule 2: No Manual Copying

Never manually copy ABI files between directories. The deploy script (`contracts/scripts/deploy.ts`) automatically exports artifacts to `shared/`.

### Rule 3: Contract Freeze Before Integration

Before integration phase:

1. Dev A freezes contract interfaces (no signature changes allowed)
2. Dev A runs deployment to testnet
3. Dev A executes export script to populate `shared/`
4. Dev B and Dev C pull latest `shared/` and integrate

### Rule 4: No Cross-Folder Imports (Except shared/)

Each package is independent. The ONLY allowed cross-package import is from `shared/`.

```
ALLOWED:
  frontend/ -> shared/
  oracle/   -> shared/
  backend/  -> shared/

FORBIDDEN:
  frontend/ -> contracts/
  oracle/   -> frontend/
  backend/  -> oracle/
```

## Getting Started

### Prerequisites

- Node.js v18 or higher
- npm v9 or higher
- Git

### For Dev A (Contracts)

```bash
cd contracts
npm install
cp .env.example .env
# Edit .env with your configuration
npx hardhat compile
npx hardhat test
```

### For Dev B (Frontend)

```bash
cd frontend
npm install
cp .env.example .env
npm run dev
```

### For Dev C (Oracle)

```bash
cd oracle
npm install
cp .env.example .env
npm run dev
```

### For Dev C (Backend)

```bash
cd backend
npm install
cp .env.example .env
npm run dev
```

## Environment Configuration

Each package has its own `.env.example` file. Copy it to `.env` and configure:

- **contracts/**: RPC URLs, deployer private key, Etherscan API key
- **frontend/**: Wallet connect project ID, API endpoints
- **oracle/**: Oracle wallet private key, RPC URL, external API keys
- **backend/**: Port, CORS origins

IMPORTANT: Never commit `.env` files. They are gitignored by default.

## Technology Stack

| Layer     | Technology           | Purpose                              |
|-----------|----------------------|--------------------------------------|
| Contracts | Solidity + Hardhat   | On-chain logic and state             |
| Frontend  | React + Vite         | User interface and wallet integration|
| Oracle    | Node.js + TypeScript | External data verification           |
| Backend   | Express + TypeScript | Stateless API and off-chain queries  |

## Contract Overview

### AssetPassport (ERC-721)

Represents a unique digital passport for a physical asset. Each token contains:

- Asset metadata (manufacturer, model, serial number)
- Current owner
- Link to event history

### EventRegistry (Append-Only Ledger)

Records lifecycle events for each asset:

- Ownership transfers
- Maintenance records
- Verification events from oracle
- Warranty claims

Events are immutable once recorded (append-only pattern).

## Developer Mapping

In this case, <br/>
Irfan acts as Developer B <br/>
Elbert acts as Developer A <br/>
Dewo acts as Developer C
